import 'package:clean_framework/clean_framework.dart';
import 'package:clean_framework/src/bloc/bloc_provider.dart';
import 'package:clean_framework/src/ui/screen.dart';
import 'package:flutter/scheduler.dart';
import 'package:flutter/widgets.dart';

abstract class Presenter<B extends Bloc, V extends ViewModel, S extends Screen>
    extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    B bloc = BlocProvider.of<B>(context);

    SchedulerBinding.instance!.addPostFrameCallback((_) {
      sendViewModelRequest(bloc);
    });

    return StreamBuilder<V>(
      stream: getViewModelStream(bloc),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return buildLoadingScreen(context);
        } else if (snapshot.hasData) {
          return buildScreen(context, bloc, snapshot.data!);
        }
        return buildErrorScreen(context, snapshot.error);
      },
    );
  }

  Stream<V> getViewModelStream(B bloc);

  S buildScreen(BuildContext context, B bloc, V viewModel);

  Widget buildLoadingScreen(BuildContext context) =>
      Container(key: Key('waitingForStream'));

  Widget buildErrorScreen(BuildContext context, Object? error) =>
      Container(key: Key('noContentFromStream'));

  /// By default, the view model pipe should have a onListen callback on the
  /// bloc, causing to be unnecessary to create an event to retrieve it. If the
  /// view model is generated by a complex logic, this method can be overridden
  /// to call an specific event.
  void sendViewModelRequest(B bloc) {}
}
